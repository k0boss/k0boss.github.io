<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>白云PC28 - 仅供参考</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #ffffff;
            color: #333333;
            line-height: 1.6;
            padding: 15px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        h1, h2, h3 {
            color: #333;
            margin-bottom: 12px;
            text-align: center;
        }
        
        h1 {
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 16px;
            color: #666;
        }
        
        .final-result-section {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
            position: relative;
        }
        
        .final-result-content {
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 12px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .final-result-content:hover {
            background-color: #f0f0f0;
        }
        
        .copy-btn {
            display: block;
            width: 100%;
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .copy-btn:hover {
            background-color: #555;
        }
        
        .copy-success {
            background-color: #4CAF50 !important;
            color: white;
        }
        
        .prediction-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .prediction-item {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }
        
        .prediction-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .prediction-content {
            font-size: 16px;
            font-weight: bold;
        }
        
        .confidence {
            color: #888;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin: 15px 0 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .detail-label {
            color: #666;
        }
        
        .detail-value {
            font-weight: bold;
        }
        
        button {
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px;
            width: calc(100% - 10px);
        }
        
        button:hover {
            background-color: #555;
        }
        
        .button-container {
            text-align: center;
            margin: 15px 0;
        }
        
        .prediction-history {
            margin-top: 20px;
            overflow-x: auto;
        }
        
        .prediction-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
            border: 1px solid #e0e0e0;
        }
        
        .prediction-table th,
        .prediction-table td {
            border: 1px solid #e0e0e0;
            padding: 8px 10px;
            text-align: center;
        }
        
        .prediction-table th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        
        .prediction-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .hit {
            color: #4CAF50;
            font-weight: bold;
            font-size: 18px;
        }
        
        .miss {
            color: #F44336;
            font-weight: bold;
            font-size: 18px;
        }
        
        .stats-section {
            margin-top: 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-item {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
        }
        
        .stat-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        
        .accuracy-summary {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
            border: 1px solid #e0e0e0;
        }
        
        .period-algorithm {
            background-color: #f0f7ff;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            border: 1px solid #cce5ff;
        }
        
        .kill-algorithm {
            background-color: #fff0f0;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            border: 1px solid #ffcccc;
        }
        
        .period-calculation {
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            margin: 8px 0;
            padding: 8px;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #cce5ff;
            display: none; /* 隐藏计算过程 */
        }
        
        .kill-calculation {
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            margin: 8px 0;
            padding: 8px;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #ffcccc;
            display: none; /* 隐藏计算过程 */
        }
        
        @media (max-width: 480px) {
            .prediction-grid, .stats-grid, .detail-grid {
                grid-template-columns: 1fr;
            }
            
            .prediction-table {
                font-size: 12px;
            }
            
            .prediction-table th,
            .prediction-table td {
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>白云PC28 - 仅供参考</h1>
            <p>基于AI强势分析的预测算法 | 整合算法 + 杀组逻辑 + 双组预测</p>
        </div>
        
        <div class="button-container">
            <button id="fetchData">获取最新数据并预测</button>
        </div>
        
        <div id="loading" class="loading" style="display: none;">
            正在获取数据并执行分析...
        </div>
        
        <div id="results" style="display: none;">
            <!-- 最终结果区域 - 移到顶部 -->
            <div class="final-result-section">
                <h3>最终预测结果</h3>
                <div class="final-result-content" id="finalOutput"></div>
                <button class="copy-btn" id="copyFinalResult">一键复制</button>
            </div>
            
            <div class="container">
                <h3>详细分析</h3>
                
                <!-- 期号算法结果显示 -->
                <div class="period-algorithm">
                    <div class="section-title">此算法仅供参考</div>
                    <div class="period-calculation" id="periodCalculation"></div>
                    <div class="prediction-content" id="periodResult"></div>
                </div>
                
                <!-- 杀组算法结果显示 -->
                <div class="kill-algorithm">
                    <div class="section-title">此算法仅供参考</div>
                    <div class="kill-calculation" id="killCalculation"></div>
                    <div class="prediction-content" id="killAlgorithmResult"></div>
                </div>
                
                <div class="prediction-grid">
                    <div class="prediction-item">
                        <div class="prediction-title">双组预测</div>
                        <div class="prediction-content" id="finalResult"></div>
                        <div class="confidence" id="baseConfidence"></div>
                    </div>
                    
                    <div class="prediction-item">
                        <div class="prediction-title">杀组推荐</div>
                        <div class="prediction-content" id="killResult"></div>
                        <div class="confidence" id="killConfidence"></div>
                    </div>
                </div>
                
                <div class="section-title">球预测分析</div>
                <div class="detail-grid">
                    <div class="detail-item">
                        <span class="detail-label">预测A球</span>
                        <span class="detail-value" id="ballA"></span>
                    </div>
                    
                    <div class="detail-item">
                        <span class="detail-label">预测B球</span>
                        <span class="detail-value" id="ballB"></span>
                    </div>
                    
                    <div class="detail-item">
                        <span class="detail-label">预测C球</span>
                        <span class="detail-value" id="ballC"></span>
                    </div>
                    
                    <div class="detail-item">
                        <span class="detail-label">预测和值</span>
                        <span class="detail-value" id="predictedSum"></span>
                    </div>
                </div>
                
                <div class="section-title">特码推荐</div>
                <div class="prediction-item">
                    <div class="prediction-content" id="specialCodes"></div>
                </div>
            </div>
            
            <div class="prediction-history">
                <h3>近期预测记录</h3>
                <table class="prediction-table" id="predictionTable">
                    <thead>
                        <tr>
                            <th>期号</th>
                            <th>时间</th>
                            <th>开奖号码</th>
                            <th>杀组</th>
                            <th>双组预测</th>
                            <th>结果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- 预测记录将通过JavaScript动态生成 -->
                    </tbody>
                </table>
                
                <div class="accuracy-summary" id="accuracySummary">
                    <!-- 准确率统计将通过JavaScript动态生成 -->
                </div>
            </div>
        </div>
        
        <div class="container" style="margin-top: 15px; text-align: center; font-size: 12px; color: #888;">
            <p>温馨提示: 彩票有风险，投注需谨慎</p>
            <p>本预测仅供参考，不构成投资建议</p>
        </div>
    </div>

    <script>
        // PC28预测器类 - 改进算法逻辑
        class PC28Predictor {
            constructor() {
                // 球预测参数
                this.ball_analysis = {
                    'ball_distributions': [new Array(10).fill(0), new Array(10).fill(0), new Array(10).fill(0)],
                    'ball_transitions': [
                        Array.from({length: 10}, () => new Array(10).fill(0)),
                        Array.from({length: 10}, () => new Array(10).fill(0)),
                        Array.from({length: 10}, () => new Array(10).fill(0))
                    ],
                    'ball_sequences': [[], [], []],
                    'type_history': [],
                    'kill_history': [],
                    'time_patterns': []
                };
                
                // 动态数据窗口
                this.data_window = [];
                
                // 时间分析参数
                this.time_analysis = {
                    'hourly_patterns': new Array(24).fill(0),
                    'daily_patterns': new Array(7).fill(0),
                    'recent_trends': [],
                    'volatility_index': 0.5,
                    'trend_strength': 0.5,
                    'momentum_index': 0.5
                };
                
                // 算法状态
                this.algorithm_state = {
                    'last_prediction': null,
                    'last_kill': null,
                    'prediction_count': {},
                    'kill_count': {},
                    'type_balance': {"大单": 0, "大双": 0, "小单": 0, "小双": 0},
                    'success_rate': 0.5,
                    'adaptation_factor': 1.0,
                    'pattern_memory': [],
                    'trend_memory': [],
                    'strong_type': null,
                    'ai_analysis_state': {},
                    'code_analysis_history': []
                };
                
                // AI学习参数
                this.ai_parameters = {
                    'learning_rate': 0.1,
                    'exploration_rate': 0.15,
                    'pattern_threshold': 0.75,
                    'confidence_decay': 0.92,
                    'trend_sensitivity': 1.3,
                    'momentum_weight': 0.8,
                    'code_analysis_depth': 20
                };
                
                // 趋势分析参数
                this.trend_analysis = {
                    'short_term_trend': 0,
                    'medium_term_trend': 0,
                    'long_term_trend': 0,
                    'trend_consistency': 0.5,
                    'volatility_level': 0.5,
                    'pattern_recognition': {},
                    'code_frequency': new Array(28).fill(0)
                };
                
                // 定义特码分类
                this.code_categories = {
                    "小单": [1, 3, 5, 7, 9, 11, 13],
                    "小双": [0, 2, 4, 6, 8, 10, 12],
                    "大单": [15, 17, 19, 21, 23, 25, 27],
                    "大双": [14, 16, 18, 20, 22, 24, 26]
                };
                
                // 尾数分析
                this.tail_analysis = {
                    'tail_frequency': new Array(10).fill(0),
                    'tail_patterns': {},
                    'recent_tails': []
                };
                
                // 预测历史记录
                this.prediction_history = [];
                
                // 时间动态杀组分析
                this.time_kill_analysis = {
                    'hourly_kill_patterns': new Array(24).fill(0),
                    'daily_kill_patterns': new Array(7).fill(0),
                    'recent_kill_success': [],
                    'kill_adaptation_rate': 1.0
                };
            }
            
            // 获取彩票数据
            async fetchLotteryData(limit = 100) {
                try {
                    const response = await fetch(`https://pc28.help/kj.json?limit=${limit}`);
                    const data = await response.json();
                    return data.data || [];
                } catch (error) {
                    console.error('获取开奖数据失败:', error);
                    // 返回模拟数据作为备用
                    return this.generateMockData(limit);
                }
            }
            
            // 生成模拟数据（备用）
            generateMockData(limit) {
                const mockData = [];
                let period = 3361000;
                
                for (let i = 0; i < limit; i++) {
                    const num1 = Math.floor(Math.random() * 10);
                    const num2 = Math.floor(Math.random() * 10);
                    const num3 = Math.floor(Math.random() * 10);
                    const sum = num1 + num2 + num3;
                    
                    let type;
                    if (sum <= 13) {
                        type = (sum % 2 === 0) ? "小双" : "小单";
                    } else {
                        type = (sum % 2 === 0) ? "大双" : "大单";
                    }
                    
                    mockData.push({
                        qihao: (period + i).toString(),
                        opennum: `${num1},${num2},${num3}`,
                        opentime: new Date(Date.now() - i * 5 * 60 * 1000).toISOString().replace('T', ' ').substring(0, 19)
                    });
                }
                
                return mockData;
            }
            
            // 解析网络开奖数据
            parseNetworkData(rawData) {
                const periods = [];
                
                for (const item of rawData) {
                    try {
                        const numbersStr = item.opennum || '';
                        const numbers = numbersStr.includes(',') ? 
                            numbersStr.split(',') : numbersStr.split('+');
                        const [num1, num2, num3] = numbers.map(Number);
                        const sumVal = num1 + num2 + num3;
                        
                        let lotteryType;
                        if (sumVal <= 13) {
                            lotteryType = (sumVal % 2 === 0) ? "小双" : "小单";
                        } else {
                            lotteryType = (sumVal % 2 === 0) ? "大双" : "大单";
                        }
                        
                        // 解析时间
                        const openTime = item.opentime || '';
                        let hour, weekday, timeStr;
                        
                        if (openTime) {
                            try {
                                const timeObj = new Date(openTime.replace(' ', 'T'));
                                hour = timeObj.getHours();
                                weekday = timeObj.getDay();
                                // 提取时间部分 (HH:MM)
                                timeStr = openTime.split(' ')[1] ? openTime.split(' ')[1].substring(0, 5) : '00:00';
                            } catch (e) {
                                hour = Math.floor(Math.random() * 24);
                                weekday = Math.floor(Math.random() * 7);
                                timeStr = '00:00';
                            }
                        } else {
                            hour = Math.floor(Math.random() * 24);
                            weekday = Math.floor(Math.random() * 7);
                            timeStr = '00:00';
                        }
                        
                        periods.push({
                            'period': item.qihao || '',
                            'numbers': [num1, num2, num3],
                            'sum': sumVal,
                            'type': lotteryType,
                            'time': openTime,
                            'timeStr': timeStr,
                            'hour': hour,
                            'weekday': weekday
                        });
                    } catch (error) {
                        console.error('解析数据出错:', error);
                        continue;
                    }
                }
                
                return periods;
            }
            
            // 新增：基于期号、和值等数据的算法
            calculatePeriodBasedPrediction(data) {
                if (data.length < 3) {
                    return null;
                }

                try {
                    // 获取前三期数据
                    const current = data[0];    // 最新一期
                    const prev1 = data[1];      // 前一期
                    const prev2 = data[2];      // 前两期

                    // A = 前两期期号的最后一位
                    const periodA = prev2.period;
                    const A = parseInt(periodA.charAt(periodA.length - 1));

                    // B = 前一期的和值
                    const B = prev1.sum;

                    // C = 最新一期的和值的个位数
                    const C = current.sum % 10;

                    // D = 近3期的b球总合 (第二个球)
                    const D = current.numbers[1] + prev1.numbers[1] + prev2.numbers[1];

                    // 计算 S = A + B + C
                    const S = A + B + C;

                    // 计算可能开奖的结果 = S - D + 1
                    let result = S - D + 1;

                    // 确保结果在有效范围内 (0-27)
                    if (result < 0) result = 0;
                    if (result > 27) result = 27;

                    // 转换为类型
                    let predictedType;
                    if (result <= 13) {
                        predictedType = (result % 2 === 0) ? "小双" : "小单";
                    } else {
                        predictedType = (result % 2 === 0) ? "大双" : "大单";
                    }

                    return {
                        type: predictedType,
                        result: result,
                        calculation: `${A}+${B}+${C}=${S}-${D}+1=${result}`
                    };
                } catch (error) {
                    console.error('期号算法计算错误:', error);
                    return null;
                }
            }

            // 新增：基于新杀组算法的预测
            calculateKillByNewAlgorithm(data) {
                if (data.length < 3) {
                    return null;
                }

                try {
                    // 获取前三期数据
                    const current = data[0];    // 最新一期
                    const prev1 = data[1];      // 前一期
                    const prev2 = data[2];      // 前两期

                    // A = 近三期和值的个位数总和
                    const A = (current.sum % 10) + (prev1.sum % 10) + (prev2.sum % 10);

                    // B = 前两期的b球
                    const B = prev1.numbers[1] + prev2.numbers[1];

                    // C = 最新一期开的和值
                    const C = current.sum;

                    // 计算 (A + B × 2) - C + 2
                    let killValue = (A + B * 2) - C + 2;

                    // 确保结果在有效范围内 (0-27)
                    if (killValue < 0) killValue = 0;
                    if (killValue > 27) killValue = 27;

                    // 转换为类型
                    let killType;
                    if (killValue <= 13) {
                        killType = (killValue % 2 === 0) ? "小双" : "小单";
                    } else {
                        killType = (killValue % 2 === 0) ? "大双" : "大单";
                    }

                    return {
                        type: killType,
                        value: killValue,
                        calculation: `(${A}+${B}×2)-${C}+2=${killValue}`,
                        components: {
                            A: A,
                            B: B,
                            C: C
                        }
                    };
                } catch (error) {
                    console.error('杀组算法计算错误:', error);
                    return null;
                }
            }

            // 分析动态走势
            analyzeDynamicTrends(data) {
                if (data.length < 10) return;
                
                // 提取和值序列
                const sums = data.map(item => item.sum);
                const types = data.map(item => item.type);
                
                // 计算不同时间尺度的趋势
                if (sums.length >= 5) {
                    this.trend_analysis.short_term_trend = this.calculateTrendDirection(sums.slice(0, 5));
                }
                
                if (sums.length >= 10) {
                    this.trend_analysis.medium_term_trend = this.calculateTrendDirection(sums.slice(0, 10));
                }
                
                if (sums.length >= 20) {
                    this.trend_analysis.long_term_trend = this.calculateTrendDirection(sums.slice(0, 20));
                }
                
                // 计算趋势一致性
                this.calculateTrendConsistency(sums);
                
                // 计算波动水平
                this.calculateVolatilityLevel(sums);
                
                // 识别模式
                this.identifyPatterns(types, sums);
                
                // 计算动量指数
                this.calculateMomentumIndex(data);
                
                // 更新特码频率分析
                this.updateCodeFrequencyAnalysis(data);
                
                // 更新尾数分析
                this.updateTailAnalysis(data);
                
                // 更新时间动态杀组分析
                this.updateTimeKillAnalysis(data);
            }
            
            // 更新时间动态杀组分析
            updateTimeKillAnalysis(data) {
                if (data.length < 10) return;
                
                // 分析每小时杀组成功率
                const hourlyKillSuccess = new Array(24).fill(0);
                const hourlyKillCount = new Array(24).fill(0);
                
                // 分析每周各天杀组成功率
                const dailyKillSuccess = new Array(7).fill(0);
                const dailyKillCount = new Array(7).fill(0);
                
                // 遍历历史数据，计算杀组成功率
                for (let i = 0; i < data.length - 1; i++) {
                    const current = data[i];
                    const next = data[i + 1];
                    
                    // 杀组成功：当前杀组不等于下一期类型
                    const killSuccess = current.type !== next.type ? 1 : 0;
                    
                    // 更新小时杀组统计
                    hourlyKillSuccess[current.hour] += killSuccess;
                    hourlyKillCount[current.hour]++;
                    
                    // 更新星期杀组统计
                    dailyKillSuccess[current.weekday] += killSuccess;
                    dailyKillCount[current.weekday]++;
                }
                
                // 计算成功率
                for (let i = 0; i < 24; i++) {
                    if (hourlyKillCount[i] > 0) {
                        this.time_kill_analysis.hourly_kill_patterns[i] = 
                            hourlyKillSuccess[i] / hourlyKillCount[i];
                    }
                }
                
                for (let i = 0; i < 7; i++) {
                    if (dailyKillCount[i] > 0) {
                        this.time_kill_analysis.daily_kill_patterns[i] = 
                            dailyKillSuccess[i] / dailyKillCount[i];
                    }
                }
                
                // 更新近期杀组成功率
                const recentKills = data.slice(0, 20);
                let recentSuccess = 0;
                for (let i = 0; i < recentKills.length - 1; i++) {
                    if (recentKills[i].type !== recentKills[i + 1].type) {
                        recentSuccess++;
                    }
                }
                
                this.time_kill_analysis.recent_kill_success.push(
                    recentKills.length > 1 ? recentSuccess / (recentKills.length - 1) : 0.5
                );
                
                if (this.time_kill_analysis.recent_kill_success.length > 10) {
                    this.time_kill_analysis.recent_kill_success.shift();
                }
                
                // 计算杀组适应率
                const recentAvg = this.time_kill_analysis.recent_kill_success.reduce((a, b) => a + b, 0) / 
                                 this.time_kill_analysis.recent_kill_success.length;
                this.time_kill_analysis.kill_adaptation_rate = Math.min(1.2, Math.max(0.8, recentAvg * 1.5));
            }
            
            // 更新尾数分析
            updateTailAnalysis(data) {
                if (data.length < 5) return;
                
                // 计算尾数频率
                const tailCounts = new Array(10).fill(0);
                
                for (const item of data.slice(0, 50)) {
                    const tail = item.sum % 10;
                    tailCounts[tail]++;
                }
                
                const total = tailCounts.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    this.tail_analysis.tail_frequency = tailCounts.map(count => count / total);
                }
                
                // 更新近期尾数
                this.tail_analysis.recent_tails = data.slice(0, 20).map(item => item.sum % 10);
                
                // 识别尾数模式
                this.identifyTailPatterns(this.tail_analysis.recent_tails);
            }
            
            // 识别尾数模式
            identifyTailPatterns(tails) {
                if (tails.length < 8) return;
                
                const tailPatterns = {};
                
                for (let i = 0; i < tails.length - 3; i++) {
                    const pattern = tails.slice(i, i + 3).join(',');
                    const nextTail = tails[i + 3];
                    
                    if (!tailPatterns[pattern]) {
                        tailPatterns[pattern] = [];
                    }
                    
                    tailPatterns[pattern].push(nextTail);
                }
                
                this.tail_analysis.tail_patterns = tailPatterns;
            }
            
            // 预测尾数
            predictTailNumbers(count = 4) {
                const tailScores = new Array(10).fill(0);
                
                // 1. 基于频率
                for (let i = 0; i < 10; i++) {
                    tailScores[i] += this.tail_analysis.tail_frequency[i] * 40;
                }
                
                // 2. 基于遗漏分析
                const recentTails = this.tail_analysis.recent_tails;
                for (let i = 0; i < 10; i++) {
                    if (recentTails.includes(i)) {
                        const lastIndex = recentTails.lastIndexOf(i);
                        const omission = recentTails.length - 1 - lastIndex;
                        tailScores[i] += (omission / recentTails.length) * 30;
                    } else {
                        // 从未出现，给高分
                        tailScores[i] += 35;
                    }
                }
                
                // 3. 基于模式识别
                if (recentTails.length >= 3) {
                    const currentPattern = recentTails.slice(0, 3).join(',');
                    if (this.tail_analysis.tail_patterns[currentPattern]) {
                        const patternTails = this.tail_analysis.tail_patterns[currentPattern];
                        const tailCounts = {};
                        
                        for (const tail of patternTails) {
                            tailCounts[tail] = (tailCounts[tail] || 0) + 1;
                        }
                        
                        for (const [tail, count] of Object.entries(tailCounts)) {
                            const probability = count / patternTails.length;
                            tailScores[parseInt(tail)] += probability * 30;
                        }
                    }
                }
                
                // 选择得分最高的尾数
                const tailWithScores = tailScores.map((score, index) => ({tail: index, score}));
                tailWithScores.sort((a, b) => b.score - a.score);
                
                return tailWithScores.slice(0, count).map(item => item.tail);
            }
            
            // 计算趋势方向
            calculateTrendDirection(dataSeries) {
                if (dataSeries.length < 3) return 0;
                
                const x = Array.from({length: dataSeries.length}, (_, i) => i);
                const y = dataSeries;
                
                // 简单线性回归计算斜率
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
                const sumX2 = x.reduce((sum, val) => sum + val * val, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                
                // 归一化斜率
                return Math.tanh(slope / 5.0);
            }
            
            // 计算趋势一致性
            calculateTrendConsistency(sums) {
                if (sums.length < 5) {
                    this.trend_analysis.trend_consistency = 0.5;
                    return;
                }
                
                const windows = [5, 8, 12];
                const consistencies = [];
                
                for (const window of windows) {
                    if (sums.length >= window) {
                        const windowSums = sums.slice(0, window);
                        const trendDirections = [];
                        
                        for (let i = 1; i < windowSums.length; i++) {
                            const direction = windowSums[i] > windowSums[i-1] ? 1 : 
                                            (windowSums[i] < windowSums[i-1] ? -1 : 0);
                            trendDirections.push(direction);
                        }
                        
                        if (trendDirections.length > 0) {
                            const consistency = trendDirections.filter(d => d === trendDirections[0]).length / trendDirections.length;
                            consistencies.push(consistency);
                        }
                    }
                }
                
                if (consistencies.length > 0) {
                    this.trend_analysis.trend_consistency = consistencies.reduce((a, b) => a + b, 0) / consistencies.length;
                } else {
                    this.trend_analysis.trend_consistency = 0.5;
                }
            }
            
            // 计算波动水平
            calculateVolatilityLevel(sums) {
                if (sums.length < 5) {
                    this.trend_analysis.volatility_level = 0.5;
                    return;
                }
                
                const windowSums = sums.slice(0, 15);
                const mean = windowSums.reduce((a, b) => a + b, 0) / windowSums.length;
                const variance = windowSums.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / windowSums.length;
                const stdDev = Math.sqrt(variance);
                
                const volatility = stdDev / mean;
                const normalizedVolatility = Math.min(1.0, volatility * 3);
                this.trend_analysis.volatility_level = normalizedVolatility;
            }
            
            // 识别模式
            identifyPatterns(types, sums) {
                if (types.length < 8) return;
                
                const typePatterns = {};
                
                for (let i = 0; i < types.length - 3; i++) {
                    const pattern = types.slice(i, i + 3);
                    const nextType = types[i + 3];
                    
                    const patternKey = pattern.join(',');
                    
                    if (!typePatterns[patternKey]) {
                        typePatterns[patternKey] = [];
                    }
                    
                    if (nextType) {
                        typePatterns[patternKey].push(nextType);
                    }
                }
                
                const patternAccuracy = {};
                for (const [pattern, outcomes] of Object.entries(typePatterns)) {
                    if (outcomes.length >= 2) {
                        const counter = {};
                        for (const outcome of outcomes) {
                            counter[outcome] = (counter[outcome] || 0) + 1;
                        }
                        
                        let mostCommon = null;
                        let maxCount = 0;
                        
                        for (const [type, count] of Object.entries(counter)) {
                            if (count > maxCount) {
                                mostCommon = type;
                                maxCount = count;
                            }
                        }
                        
                        const accuracy = maxCount / outcomes.length;
                        patternAccuracy[pattern] = [mostCommon, accuracy];
                    }
                }
                
                this.trend_analysis.pattern_recognition = patternAccuracy;
            }
            
            // 计算动量指数
            calculateMomentumIndex(data) {
                if (data.length < 8) {
                    this.time_analysis.momentum_index = 0.5;
                    return;
                }
                
                const sums = data.slice(0, 15).map(item => item.sum);
                const momentumIndicators = [];
                
                if (sums.length >= 4) {
                    const shortMomentum = (sums[0] - sums[3]) / 3.0;
                    momentumIndicators.push(shortMomentum);
                }
                
                if (sums.length >= 7) {
                    const mediumMomentum = (sums[0] - sums[6]) / 6.0;
                    momentumIndicators.push(mediumMomentum);
                }
                
                if (sums.length >= 11) {
                    const longMomentum = (sums[0] - sums[10]) / 10.0;
                    momentumIndicators.push(longMomentum);
                }
                
                if (momentumIndicators.length > 0) {
                    const avgMomentum = momentumIndicators.reduce((a, b) => a + b, 0) / momentumIndicators.length;
                    const normalizedMomentum = Math.tanh(avgMomentum / 5.0) * 0.5 + 0.5;
                    this.time_analysis.momentum_index = normalizedMomentum;
                } else {
                    this.time_analysis.momentum_index = 0.5;
                }
            }
            
            // 更新特码频率分析
            updateCodeFrequencyAnalysis(data) {
                if (data.length < 5) return;
                
                // 使用时间衰减权重
                const weights = Array.from({length: Math.min(30, data.length)}, (_, i) => Math.exp(-i * 0.15));
                const weightSum = weights.reduce((a, b) => a + b, 0);
                const normalizedWeights = weights.map(w => w / weightSum);
                
                // 重置频率数组
                this.trend_analysis.code_frequency = new Array(28).fill(0);
                
                // 加权更新频率
                for (let idx = 0; idx < Math.min(30, data.length); idx++) {
                    const sumVal = data[idx].sum;
                    const weight = idx < normalizedWeights.length ? normalizedWeights[idx] : 1.0;
                    
                    if (sumVal >= 0 && sumVal <= 27) {
                        this.trend_analysis.code_frequency[sumVal] += weight;
                    }
                }
                
                // 归一化
                const total = this.trend_analysis.code_frequency.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    this.trend_analysis.code_frequency = this.trend_analysis.code_frequency.map(val => val / total);
                }
            }
            
            // 基于球预测的核心预测算法
            sumBasedPrediction(data) {
                if (data.length < 5) {
                    return ["大单大双", "大双", [0, 0, 0], [50, 50, 50]];
                }
                
                this.updateBallAnalysis(data);
                
                const [predictedBalls, ballConfidences] = this.predictBallsEnhanced(data);
                
                const [finalResult, killResult] = this.analyzeAIStateAndKill(data, predictedBalls);
                
                this.adaptiveLearning(data, 0.5);
                
                return [finalResult, killResult, predictedBalls, ballConfidences];
            }
            
            // 更新球分析数据
            updateBallAnalysis(data) {
                if (data.length < 2) return;
                
                // 重置分布
                for (let i = 0; i < 3; i++) {
                    this.ball_analysis.ball_distributions[i] = new Array(10).fill(0);
                }
                
                // 时间权重
                const timeWeights = Array.from({length: Math.min(80, data.length)}, (_, i) => Math.exp(-i * 0.1));
                const weightSum = timeWeights.reduce((a, b) => a + b, 0);
                const normalizedWeights = timeWeights.map(w => w / weightSum);
                
                for (let idx = 0; idx < Math.min(80, data.length); idx++) {
                    const numbers = data[idx].numbers;
                    const weight = idx < normalizedWeights.length ? normalizedWeights[idx] : 1.0;
                    
                    for (let i = 0; i < 3; i++) {
                        if (numbers[i] >= 0 && numbers[i] <= 9) {
                            this.ball_analysis.ball_distributions[i][numbers[i]] += weight;
                            this.ball_analysis.ball_sequences[i].push(numbers[i]);
                            
                            // 保持序列长度
                            if (this.ball_analysis.ball_sequences[i].length > 25) {
                                this.ball_analysis.ball_sequences[i].shift();
                            }
                        }
                    }
                }
                
                // 归一化分布
                for (let i = 0; i < 3; i++) {
                    const total = this.ball_analysis.ball_distributions[i].reduce((a, b) => a + b, 0);
                    if (total > 0) {
                        this.ball_analysis.ball_distributions[i] = this.ball_analysis.ball_distributions[i].map(val => val / total);
                    }
                }
                
                // 更新转移矩阵
                for (let ballIdx = 0; ballIdx < 3; ballIdx++) {
                    // 重置转移矩阵
                    this.ball_analysis.ball_transitions[ballIdx] = Array.from({length: 10}, () => new Array(10).fill(0));
                    
                    for (let i = 0; i < Math.min(data.length - 1, 50); i++) {
                        const fromBall = data[i].numbers[ballIdx];
                        const toBall = data[i + 1].numbers[ballIdx];
                        const weight = i < normalizedWeights.length ? normalizedWeights[i] : 1.0;
                        
                        if (fromBall >= 0 && fromBall <= 9 && toBall >= 0 && toBall <= 9) {
                            this.ball_analysis.ball_transitions[ballIdx][fromBall][toBall] += weight;
                        }
                    }
                    
                    // 归一化转移矩阵
                    for (let from = 0; from < 10; from++) {
                        const rowSum = this.ball_analysis.ball_transitions[ballIdx][from].reduce((a, b) => a + b, 0);
                        if (rowSum > 0) {
                            for (let to = 0; to < 10; to++) {
                                this.ball_analysis.ball_transitions[ballIdx][from][to] /= rowSum;
                            }
                        }
                    }
                }
            }
            
            // 增强的球预测算法
            predictBallsEnhanced(data) {
                if (data.length < 5) {
                    const randomBalls = [
                        Math.floor(Math.random() * 10),
                        Math.floor(Math.random() * 10),
                        Math.floor(Math.random() * 10)
                    ];
                    return [randomBalls, [50, 50, 50]];
                }
                
                this.analyzeTypePatterns(data);
                this.analyzeTimePatterns(data);
                this.analyzeDynamicTrends(data);
                
                const currentBalls = data[0].numbers;
                const predictedBalls = [];
                const confidenceScores = [];
                
                for (let ballIdx = 0; ballIdx < 3; ballIdx++) {
                    const predictions = [];
                    const weights = [];
                    const methodScores = [];
                    
                    // 1. 基于转移矩阵
                    const [transPred, transScore] = this.predictByTransition(ballIdx, currentBalls[ballIdx]);
                    predictions.push(transPred);
                    weights.push(1.2 * this.algorithm_state.adaptation_factor);
                    methodScores.push(transScore);
                    
                    // 2. 基于近期趋势
                    const [trendPred, trendScore] = this.predictByTrend(ballIdx, data);
                    predictions.push(trendPred);
                    weights.push(1.1 * this.time_analysis.trend_strength);
                    methodScores.push(trendScore);
                    
                    // 3. 基于分布
                    const [distPred, distScore] = this.predictByDistribution(ballIdx);
                    predictions.push(distPred);
                    weights.push(0.9);
                    methodScores.push(distScore);
                    
                    // 加权投票
                    const ballScores = new Array(10).fill(0);
                    
                    for (let i = 0; i < predictions.length; i++) {
                        const pred = predictions[i];
                        const weight = weights[i];
                        const score = methodScores[i];
                        
                        ballScores[pred] += weight * score;
                    }
                    
                    // 选择最佳球
                    let bestBall = 0;
                    let maxScore = ballScores[0];
                    
                    for (let i = 1; i < 10; i++) {
                        if (ballScores[i] > maxScore) {
                            maxScore = ballScores[i];
                            bestBall = i;
                        }
                    }
                    
                    const confidence = Math.min(95, maxScore / weights.reduce((a, b) => a + b, 0) * 100);
                    
                    predictedBalls.push(bestBall);
                    confidenceScores.push(confidence);
                }
                
                return [predictedBalls, confidenceScores];
            }
            
            // 基于转移矩阵预测
            predictByTransition(ballIdx, currentBall) {
                if (currentBall < 0 || currentBall > 9) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const transitionProbs = this.ball_analysis.ball_transitions[ballIdx][currentBall];
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                
                const combinedProbs = transitionProbs.map((prob, i) => prob * (distribution[i] + 0.01));
                
                let bestBall = 0;
                let maxProb = combinedProbs[0];
                
                for (let i = 1; i < 10; i++) {
                    if (combinedProbs[i] > maxProb) {
                        maxProb = combinedProbs[i];
                        bestBall = i;
                    }
                }
                
                const confidence = Math.min(0.9, maxProb / combinedProbs.reduce((a, b) => a + b, 0) * 2);
                
                return [bestBall, confidence];
            }
            
            // 基于趋势预测
            predictByTrend(ballIdx, data) {
                if (data.length < 3) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const recentBalls = data.slice(0, 8).map(item => item.numbers[ballIdx]);
                
                if (recentBalls.length >= 5) {
                    const trendWeights = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8].slice(0, recentBalls.length);
                    const weightSum = trendWeights.reduce((a, b) => a + b, 0);
                    const normalizedWeights = trendWeights.map(w => w / weightSum);
                    
                    const weightedAvg = recentBalls.reduce((sum, val, i) => sum + val * normalizedWeights[i], 0);
                    
                    const shortAvg = recentBalls.slice(0, 3).reduce((sum, val, i) => sum + val * normalizedWeights[i], 0) / 
                                   normalizedWeights.slice(0, 3).reduce((a, b) => a + b, 0);
                    const longAvg = weightedAvg;
                    
                    const trendDirection = shortAvg > longAvg ? 1 : -1;
                    const trendStrength = Math.min(1.0, Math.abs(shortAvg - longAvg) / 3.0);
                    
                    const adjustment = trendDirection * trendStrength * 2;
                    let predicted = Math.round(weightedAvg + adjustment);
                    predicted = Math.max(0, Math.min(9, predicted));
                    
                    const confidence = 0.5 + trendStrength * 0.3;
                    
                    return [predicted, confidence];
                }
                
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                let bestBall = 0;
                let maxProb = distribution[0];
                
                for (let i = 1; i < 10; i++) {
                    if (distribution[i] > maxProb) {
                        maxProb = distribution[i];
                        bestBall = i;
                    }
                }
                
                return [bestBall, 0.6];
            }
            
            // 基于分布预测
            predictByDistribution(ballIdx) {
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                
                // 如果分布比较均匀，使用序列中的热门球
                const maxVal = Math.max(...distribution);
                const minVal = Math.min(...distribution);
                
                if (maxVal - minVal < 0.1) {
                    const sequence = this.ball_analysis.ball_sequences[ballIdx];
                    if (sequence.length >= 3) {
                        const recentCounter = {};
                        for (const ball of sequence.slice(-8)) {
                            recentCounter[ball] = (recentCounter[ball] || 0) + 1;
                        }
                        
                        let hotBall = 0;
                        let maxCount = 0;
                        
                        for (const [ball, count] of Object.entries(recentCounter)) {
                            if (count > maxCount) {
                                maxCount = count;
                                hotBall = parseInt(ball);
                            }
                        }
                        
                        return [hotBall, 0.55];
                    }
                }
                
                let bestBall = 0;
                let maxProb = distribution[0];
                
                for (let i = 1; i < 10; i++) {
                    if (distribution[i] > maxProb) {
                        maxProb = distribution[i];
                        bestBall = i;
                    }
                }
                
                const confidence = Math.min(0.8, maxProb * 1.5);
                
                return [bestBall, confidence];
            }
            
            // 分析类型模式
            analyzeTypePatterns(data) {
                if (data.length < 10) return;
                
                const recentTypes = data.slice(0, 20).map(item => item.type);
                const typeCounter = {};
                
                for (const type of recentTypes) {
                    typeCounter[type] = (typeCounter[type] || 0) + 1;
                }
                
                const total = recentTypes.length;
                
                for (const typeName of ["大单", "大双", "小单", "小双"]) {
                    const count = typeCounter[typeName] || 0;
                    this.algorithm_state.type_balance[typeName] = total > 0 ? count / total : 0.25;
                }
            }
            
            // 分析时间模式
            analyzeTimePatterns(data) {
                if (data.length < 10) return;
                
                const hourlyCounts = new Array(24).fill(0);
                for (const item of data) {
                    hourlyCounts[item.hour]++;
                }
                
                const totalHours = data.length;
                if (totalHours > 0) {
                    this.time_analysis.hourly_patterns = hourlyCounts.map(count => count / totalHours);
                }
                
                const dailyCounts = new Array(7).fill(0);
                for (const item of data) {
                    dailyCounts[item.weekday]++;
                }
                
                const totalDays = data.length;
                if (totalDays > 0) {
                    this.time_analysis.daily_patterns = dailyCounts.map(count => count / totalDays);
                }
                
                const recentSums = data.slice(0, 10).map(item => item.sum);
                if (recentSums.length >= 5) {
                    const trendValues = [];
                    for (let i = 1; i < recentSums.length; i++) {
                        trendValues.push(recentSums[i] - recentSums[i-1]);
                    }
                    
                    if (trendValues.length > 0) {
                        const avgTrend = trendValues.reduce((a, b) => a + b, 0) / trendValues.length;
                        const trendStrength = Math.min(1.0, Math.abs(avgTrend) / 5.0);
                        this.time_analysis.trend_strength = trendStrength;
                    }
                }
            }
            
            // 自适应学习算法
            adaptiveLearning(data, predictionAccuracy) {
                this.algorithm_state.success_rate = 
                    this.algorithm_state.success_rate * 0.9 + predictionAccuracy * 0.1;
                
                if (predictionAccuracy > 0.6) {
                    this.algorithm_state.adaptation_factor *= 1.05;
                } else {
                    this.algorithm_state.adaptation_factor *= 0.95;
                }
                
                this.algorithm_state.adaptation_factor = Math.max(0.5, Math.min(2.0, this.algorithm_state.adaptation_factor));
                
                if (data.length >= 5) {
                    const recentPattern = data.slice(0, 5).map(item => item.type);
                    this.algorithm_state.pattern_memory.push(recentPattern);
                    
                    if (this.algorithm_state.pattern_memory.length > 15) {
                        this.algorithm_state.pattern_memory.shift();
                    }
                }
            }
            
            // 同时分析AI状态和杀组推荐
            analyzeAIStateAndKill(data, predictedBalls) {
                if (data.length < 10) {
                    return ["大单大双", "大双"];
                }
                
                this.analyzeDynamicTrends(data);
                
                const predictedSum = predictedBalls.reduce((a, b) => a + b, 0);
                const predictedType = this.sumToType(predictedSum);
                
                const strongType = this.calculateStrongType(data);
                this.algorithm_state.strong_type = strongType;
                
                this.updateAIAnalysisState(data, strongType);
                
                // 获取期号算法预测结果
                const periodPrediction = this.calculatePeriodBasedPrediction(data);

                const finalTypes = this.generateDoublePredictionBasedOnStrongType(data, strongType, periodPrediction);

                // 获取新杀组算法预测结果
                const killPrediction = this.calculateKillByNewAlgorithm(data);

                const killType = this.selectKillBasedOnAIState(finalTypes, predictedType, data, strongType, periodPrediction, killPrediction);

                return [finalTypes.join(''), killType];
            }
            
            // 计算强势类型
            calculateStrongType(data) {
                if (data.length < 10) return "大单";
                
                const typeScores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                // 1. 基于趋势分析
                const trendScore = this.calculateTrendBasedScore(data);
                for (const [typeName, score] of Object.entries(trendScore)) {
                    typeScores[typeName] += score * 0.3;
                }
                
                // 2. 基于动量分析
                const momentumScore = this.calculateMomentumBasedScore(data);
                for (const [typeName, score] of Object.entries(momentumScore)) {
                    typeScores[typeName] += score * 0.25;
                }
                
                // 3. 基于模式识别
                const patternScore = this.calculatePatternBasedScore(data);
                for (const [typeName, score] of Object.entries(patternScore)) {
                    typeScores[typeName] += score * 0.2;
                }
                
                // 4. 基于遗漏分析
                const omissionScore = this.calculateOmissionBasedScore(data);
                for (const [typeName, score] of Object.entries(omissionScore)) {
                    typeScores[typeName] += score * 0.15;
                }
                
                // 5. 基于时间模式
                const timeScore = this.calculateTimeBasedScore(data);
                for (const [typeName, score] of Object.entries(timeScore)) {
                    typeScores[typeName] += score * 0.1;
                }
                
                let maxType = "大单";
                let maxScore = typeScores["大单"];
                
                for (const [typeName, score] of Object.entries(typeScores)) {
                    if (score > maxScore) {
                        maxScore = score;
                        maxType = typeName;
                    }
                }
                
                return maxType;
            }
            
            // 基于趋势分析的分数计算
            calculateTrendBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const shortTrend = this.trend_analysis.short_term_trend;
                const trendConsistency = this.trend_analysis.trend_consistency;
                
                if (Math.abs(shortTrend) > 0.1 && trendConsistency > 0.6) {
                    const currentSum = data[0].sum;
                    
                    if (shortTrend > 0) {
                        if (currentSum <= 13) {
                            scores["大单"] = 0.8;
                            scores["大双"] = 0.7;
                        } else {
                            scores["大单"] = 0.9;
                            scores["大双"] = 0.8;
                        }
                    } else {
                        if (currentSum >= 14) {
                            scores["小单"] = 0.8;
                            scores["小双"] = 0.7;
                        } else {
                            scores["小单"] = 0.9;
                            scores["小双"] = 0.8;
                        }
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于动量分析的分数计算
            calculateMomentumBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const momentum = this.time_analysis.momentum_index;
                
                if (momentum > 0.7) {
                    const currentType = data[0].type;
                    scores[currentType] = 0.9;
                    
                    const oppositeTypes = this.getOppositeTypes(currentType);
                    for (const oppType of oppositeTypes) {
                        scores[oppType] = 0.2;
                    }
                } else if (momentum < 0.3) {
                    const currentType = data[0].type;
                    scores[currentType] = 0.3;
                    
                    for (const typeName of Object.keys(scores)) {
                        if (typeName !== currentType) {
                            scores[typeName] = 0.7;
                        }
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于模式识别的分数计算
            calculatePatternBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const recentTypes = data.slice(0, 5).map(item => item.type);
                
                const pattern = recentTypes.join(',');
                if (this.trend_analysis.pattern_recognition[pattern]) {
                    const [nextType, accuracy] = this.trend_analysis.pattern_recognition[pattern];
                    if (accuracy > 0.6) {
                        scores[nextType] = accuracy;
                    } else {
                        for (const typeName of Object.keys(scores)) {
                            scores[typeName] = 0.5;
                        }
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于遗漏分析的分数计算
            calculateOmissionBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const recentTypes = data.slice(0, 20).map(item => item.type);
                const allTypes = ["大单", "大双", "小单", "小双"];
                
                const omissions = {};
                for (const typeName of allTypes) {
                    if (recentTypes.includes(typeName)) {
                        const lastIndex = recentTypes.length - 1 - [...recentTypes].reverse().indexOf(typeName);
                        omissions[typeName] = lastIndex;
                    } else {
                        omissions[typeName] = recentTypes.length;
                    }
                }
                
                const maxOmission = Math.max(...Object.values(omissions));
                for (const [typeName, omission] of Object.entries(omissions)) {
                    const omissionFactor = omission / maxOmission;
                    scores[typeName] = omissionFactor;
                }
                
                return scores;
            }
            
            // 基于时间模式的分数计算
            calculateTimeBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const currentHour = data[0].hour;
                
                const hourData = data.filter(item => item.hour === currentHour);
                if (hourData.length >= 3) {
                    const hourTypes = hourData.map(item => item.type);
                    const typeCounter = {};
                    
                    for (const type of hourTypes) {
                        typeCounter[type] = (typeCounter[type] || 0) + 1;
                    }
                    
                    const total = hourTypes.length;
                    
                    for (const [typeName, count] of Object.entries(typeCounter)) {
                        scores[typeName] = count / total;
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.25;
                    }
                }
                
                return scores;
            }
            
            // 获取相反类型
            getOppositeTypes(typeName) {
                const opposites = {
                    "大单": ["小双"],
                    "大双": ["小单"],
                    "小单": ["大双"],
                    "小双": ["大单"]
                };
                return opposites[typeName] || [];
            }
            
            // 更新AI分析状态
            updateAIAnalysisState(data, strongType) {
                this.algorithm_state.ai_analysis_state = {
                    'strong_type': strongType,
                    'trend_direction': this.trend_analysis.short_term_trend,
                    'trend_consistency': this.trend_analysis.trend_consistency,
                    'momentum_index': this.time_analysis.momentum_index,
                    'volatility_level': this.trend_analysis.volatility_level,
                    'timestamp': new Date()
                };
            }
            
            // 基于强势类型生成双组预测
            generateDoublePredictionBasedOnStrongType(data, strongType, periodPrediction) {
                const finalTypes = [strongType];

                const allTypes = ["大单", "大双", "小单", "小双"];
                const remainingTypes = allTypes.filter(t => t !== strongType);

                // 增强的双组选择逻辑，考虑期号算法
                const secondTypeScores = {};
                for (const typeName of remainingTypes) {
                    let score = 0;

                    // 1. 趋势分析分数
                    const trendScore = this.calculateTrendBasedScore(data);
                    score += trendScore[typeName] * 0.25; // 降低权重，为期号算法留空间

                    // 2. 遗漏分析分数
                    const omissionScore = this.calculateOmissionBasedScore(data);
                    score += omissionScore[typeName] * 0.2;

                    // 3. 模式识别分数
                    const patternScore = this.calculatePatternBasedScore(data);
                    score += patternScore[typeName] * 0.15;

                    // 4. 时间模式分数
                    const timeScore = this.calculateTimeBasedScore(data);
                    score += timeScore[typeName] * 0.1;

                    // 5. 类型平衡分数
                    const balanceScore = 1 - (this.algorithm_state.type_balance[typeName] || 0.25);
                    score += balanceScore * 0.1;

                    // 6. 新增：期号算法分数（重要因素）
                    if (periodPrediction && periodPrediction.type === typeName) {
                        score += 0.4; // 给予较高权重
                    }

                    secondTypeScores[typeName] = score;
                }

                // 选择分数最高的作为第二类型
                let secondType = remainingTypes[0];
                let maxScore = secondTypeScores[secondType];

                for (const [typeName, score] of Object.entries(secondTypeScores)) {
                    if (score > maxScore) {
                        maxScore = score;
                        secondType = typeName;
                    }
                }

                // 如果期号算法预测的类型不在最终结果中，考虑替换
                if (periodPrediction && 
                    !finalTypes.includes(periodPrediction.type) && 
                    this.isPeriodPredictionReliable(data, periodPrediction)) {
                    
                    // 如果期号算法置信度高，用其替换第二类型
                    const periodType = periodPrediction.type;
                    if (remainingTypes.includes(periodType)) {
                        secondType = periodType;
                    }
                }

                finalTypes.push(secondType);

                return finalTypes;
            }

            // 新增：评估期号算法的可靠性
            isPeriodPredictionReliable(data, periodPrediction) {
                if (data.length < 10) return false;

                // 检查历史准确率
                let correctCount = 0;
                let totalTests = 0;

                for (let i = 0; i < data.length - 3; i++) {
                    const testData = data.slice(i, i + 3);
                    const actualNext = data[i + 3];
                    
                    try {
                        const testPrediction = this.calculatePeriodBasedPrediction(testData);
                        if (testPrediction && testPrediction.type === actualNext.type) {
                            correctCount++;
                        }
                        totalTests++;
                    } catch (e) {
                        continue;
                    }
                }

                const accuracy = totalTests > 0 ? correctCount / totalTests : 0;
                
                // 如果历史准确率高于60%，认为可靠
                return accuracy > 0.6;
            }
            
            // 基于AI分析状态选择杀组 - 增强版（整合新杀组算法）
            selectKillBasedOnAIState(finalTypes, predictedType, data, strongType, periodPrediction, killPrediction) {
                const allTypes = ["大单", "大双", "小单", "小双"];

                // 杀组候选：不能是强势类型，不能是预测的双组，不能是球预测类型，也不能是期号算法预测的类型
                let killCandidates = allTypes.filter(
                    t => t !== strongType && 
                         !finalTypes.includes(t) && 
                         t !== predictedType &&
                         (!periodPrediction || t !== periodPrediction.type)
                );

                if (killCandidates.length === 0) {
                    // 如果没有候选，放宽条件：只要不是强势类型和期号算法类型
                    killCandidates = allTypes.filter(t => 
                        t !== strongType && 
                        (!periodPrediction || t !== periodPrediction.type)
                    );
                }

                if (killCandidates.length === 0) {
                    // 如果还是没有候选，使用所有类型
                    killCandidates = allTypes;
                }

                // 增强的时间动态杀组算法
                const killScores = {};
                for (const candidate of killCandidates) {
                    let score = 0;
                    
                    // 1. 遗漏值分数（遗漏越久，越适合作为杀组）
                    const recentTypes = data.slice(0, 25).map(item => item.type);
                    if (recentTypes.includes(candidate)) {
                        const lastIndex = recentTypes.length - 1 - [...recentTypes].reverse().indexOf(candidate);
                        const omission = lastIndex;
                        score += (omission / recentTypes.length) * 30;
                    } else {
                        // 从未出现，分数最高
                        score += 35;
                    }
                    
                    // 2. 时间动态杀组分析
                    const currentHour = data[0].hour;
                    const currentWeekday = data[0].weekday;
                    
                    // 小时杀组成功率
                    const hourlyKillSuccess = this.time_kill_analysis.hourly_kill_patterns[currentHour] || 0.5;
                    score += hourlyKillSuccess * 20;
                    
                    // 星期杀组成功率
                    const dailyKillSuccess = this.time_kill_analysis.daily_kill_patterns[currentWeekday] || 0.5;
                    score += dailyKillSuccess * 15;
                    
                    // 3. 趋势分析分数（与当前趋势相反的更适合作为杀组）
                    const currentTrend = this.trend_analysis.short_term_trend;
                    if (Math.abs(currentTrend) > 0.15) {
                        if (currentTrend > 0) { // 上升趋势
                            if (["小单", "小双"].includes(candidate)) { // 选择小数类型
                                score += 15;
                            }
                        } else { // 下降趋势
                            if (["大单", "大双"].includes(candidate)) { // 选择大数类型
                                score += 15;
                            }
                        }
                    }
                    
                    // 4. 历史使用频率（使用频率低的更适合作为杀组）
                    const killCount = this.algorithm_state.kill_count[candidate] || 0;
                    score += (1 - Math.min(killCount / 12, 1)) * 10;
                    
                    // 5. 类型平衡分数（出现频率低的类型更适合作为杀组）
                    const typeBalance = this.algorithm_state.type_balance[candidate] || 0.25;
                    score += (1 - typeBalance) * 10;
                    
                    // 6. 新增：如果期号算法预测了某个类型，避免将其作为杀组
                    if (periodPrediction && candidate === periodPrediction.type) {
                        score -= 25; // 大幅降低分数
                    }

                    // 7. 新增：如果新杀组算法预测了某个类型，优先选择它作为杀组
                    if (killPrediction && candidate === killPrediction.type) {
                        score += 40; // 大幅增加分数
                    }

                    killScores[candidate] = score;
                }
                
                if (Object.keys(killScores).length > 0) {
                    let bestKill = killCandidates[0];
                    let maxScore = killScores[bestKill];
                    
                    for (const [candidate, score] of Object.entries(killScores)) {
                        if (score > maxScore) {
                            maxScore = score;
                            bestKill = candidate;
                        }
                    }
                    
                    // 记录杀组使用历史
                    this.algorithm_state.kill_count[bestKill] = (this.algorithm_state.kill_count[bestKill] || 0) + 1;
                    return bestKill;
                } else {
                    // 最后的手段：选择与强势类型和期号算法类型不同的类型
                    const candidates = allTypes.filter(t => 
                        t !== strongType && 
                        (!periodPrediction || t !== periodPrediction.type)
                    );
                    const bestKill = candidates.length > 0 ? 
                        candidates[Math.floor(Math.random() * candidates.length)] : 
                        allTypes[Math.floor(Math.random() * allTypes.length)];
                    this.algorithm_state.kill_count[bestKill] = (this.algorithm_state.kill_count[bestKill] || 0) + 1;
                    return bestKill;
                }
            }
            
            // 和值转类型
            sumToType(sumVal) {
                if (sumVal <= 13) {
                    return (sumVal % 2 === 0) ? "小双" : "小单";
                } else {
                    return (sumVal % 2 === 0) ? "大双" : "大单";
                }
            }
            
            // 计算置信度
            calculateConfidence(data, finalResult, killResult, ballConfidences) {
                if (data.length < 5) {
                    return [60, 55, 50];
                }
                
                let baseConfidence = 65;
                let killConfidence = 60;
                let ballConfidence = ballConfidences.length > 0 ? 
                    ballConfidences.reduce((a, b) => a + b, 0) / ballConfidences.length : 50;
                
                if (data.length >= 80) {
                    baseConfidence += 20;
                    killConfidence += 15;
                    ballConfidence += 15;
                } else if (data.length >= 50) {
                    baseConfidence += 15;
                    killConfidence += 10;
                    ballConfidence += 10;
                } else if (data.length >= 30) {
                    baseConfidence += 10;
                    killConfidence += 8;
                    ballConfidence += 8;
                } else if (data.length >= 20) {
                    baseConfidence += 5;
                    killConfidence += 5;
                    ballConfidence += 5;
                }
                
                if (ballConfidence > 75) {
                    baseConfidence += 12;
                    killConfidence += 8;
                } else if (ballConfidence > 65) {
                    baseConfidence += 8;
                    killConfidence += 5;
                }
                
                const predictedTypes = [];
                for (let i = 0; i < finalResult.length; i += 2) {
                    predictedTypes.push(finalResult.substring(i, i + 2));
                }
                
                if (!predictedTypes.includes(killResult)) {
                    baseConfidence += 8;
                    killConfidence += 8;
                }
                
                const strongType = this.algorithm_state.strong_type;
                if (strongType && predictedTypes.includes(strongType)) {
                    baseConfidence += 10;
                    killConfidence += 5;
                }
                
                const currentHour = new Date().getHours();
                const hourConfidence = this.time_analysis.hourly_patterns[currentHour] * 20;
                baseConfidence += hourConfidence;
                killConfidence += hourConfidence * 0.8;
                
                const trendConfidence = this.time_analysis.trend_strength * 15;
                baseConfidence += trendConfidence;
                ballConfidence += trendConfidence;
                
                const adaptationConfidence = (this.algorithm_state.adaptation_factor - 0.5) * 10;
                baseConfidence += adaptationConfidence;
                
                const consistencyConfidence = this.trend_analysis.trend_consistency * 12;
                baseConfidence += consistencyConfidence;
                killConfidence += consistencyConfidence * 0.7;
                
                const momentumConfidence = Math.abs(this.time_analysis.momentum_index - 0.5) * 20;
                baseConfidence += momentumConfidence;
                
                return [
                    Math.min(95, Math.max(50, baseConfidence)),
                    Math.min(90, Math.max(40, killConfidence)),
                    Math.min(95, ballConfidence)
                ];
            }
            
            // 生成精准的特码
            generatePreciseCodes(data, finalResult, predictedBalls) {
                if (data.length < 5) {
                    return [7, 11, 19, 23];
                }
                
                // 保存最终结果用于特码分析
                this.last_final_result = finalResult;
                
                // 使用增强的特码分析算法
                const specialCodes = this.enhancedCodeAnalysis(data);
                
                // 记录特码分析历史
                this.algorithm_state.code_analysis_history.push({
                    'codes': [...specialCodes],
                    'timestamp': new Date(),
                    'data_size': data.length
                });
                
                if (this.algorithm_state.code_analysis_history.length > 50) {
                    this.algorithm_state.code_analysis_history.shift();
                }
                
                return specialCodes;
            }
            
            // 增强的特码分析算法
            enhancedCodeAnalysis(data) {
                if (data.length < 10) {
                    // 默认返回一些常见特码
                    return [7, 11, 19, 23];
                }
                
                // 分析历史特码模式
                const recentCodes = data.slice(0, this.ai_parameters.code_analysis_depth).map(item => item.sum);
                
                // 强势类型影响
                const strongType = this.algorithm_state.strong_type || "大单";
                
                // 获取双组预测类型
                let predictedTypes = [];
                if (this.last_final_result) {
                    // 从上次预测结果获取类型
                    const finalResult = this.last_final_result;
                    for (let i = 0; i < finalResult.length; i += 2) {
                        predictedTypes.push(finalResult.substring(i, i + 2));
                    }
                } else {
                    // 默认使用强势类型和另一个类型
                    predictedTypes = [strongType];
                    const otherTypes = ["大单", "大双", "小单", "小双"].filter(t => t !== strongType);
                    if (otherTypes.length > 0) {
                        predictedTypes.push(otherTypes[Math.floor(Math.random() * otherTypes.length)]);
                    }
                }
                
                // 计算各类型特码的权重
                const codeWeights = {};
                
                for (const [typeName, codes] of Object.entries(this.code_categories)) {
                    for (const code of codes) {
                        // 基础权重
                        let weight = 1.0;
                        
                        // 频率权重
                        weight *= (1 + this.trend_analysis.code_frequency[code] * 2);
                        
                        // 类型权重：预测类型权重更高
                        if (predictedTypes.includes(typeName)) {
                            weight *= 1.5;
                        }
                        
                        // 强势类型权重更高
                        if (typeName === strongType) {
                            weight *= 1.3;
                        }
                        
                        // 遗漏分析
                        if (recentCodes.includes(code)) {
                            const lastIndex = recentCodes.length - 1 - [...recentCodes].reverse().indexOf(code);
                            const omission = lastIndex;
                            // 遗漏越久，权重越高
                            weight *= (1 + omission / recentCodes.length * 0.5);
                        } else {
                            // 从未出现，权重更高
                            weight *= 1.2;
                        }
                        
                        codeWeights[code] = weight;
                    }
                }
                
                // 按类型分配特码
                const finalCodes = [];
                
                // 优先从预测类型中选择
                for (const predType of predictedTypes) {
                    if (finalCodes.length >= 4) break;
                    
                    const typeCodes = [...this.code_categories[predType]];
                    // 按权重排序
                    typeCodes.sort((a, b) => (codeWeights[b] || 0) - (codeWeights[a] || 0));
                    
                    // 选择前2个
                    for (const code of typeCodes.slice(0, 2)) {
                        if (!finalCodes.includes(code) && finalCodes.length < 4) {
                            finalCodes.push(code);
                        }
                    }
                }
                
                // 如果不足4个，从其他类型补充
                if (finalCodes.length < 4) {
                    const allCodes = [];
                    for (const codes of Object.values(this.code_categories)) {
                        allCodes.push(...codes);
                    }
                    
                    // 按权重排序
                    allCodes.sort((a, b) => (codeWeights[b] || 0) - (codeWeights[a] || 0));
                    
                    for (const code of allCodes) {
                        if (!finalCodes.includes(code) && finalCodes.length < 4) {
                            finalCodes.push(code);
                        }
                    }
                }
                
                return finalCodes.slice(0, 4);
            }
            
            // 获取下一期期号的后两位
            getNextPeriodNumber(data) {
                if (!data || data.length === 0) {
                    return "00";
                }
                
                // 获取最新期号
                let latestPeriod;
                if (Array.isArray(data)) {
                    // 网络数据
                    latestPeriod = data[0].period;
                } else {
                    // 手动输入数据
                    // 这里简化处理，实际应用中可能需要解析
                    latestPeriod = "000000";
                }
                
                // 提取数字部分
                const periodDigits = latestPeriod.replace(/\D/g, '');
                if (!periodDigits) {
                    return "00";
                }
                
                // 计算下一期期号
                try {
                    let nextPeriod = parseInt(periodDigits) + 1;
                    // 取后两位，如果到99后回到00
                    const nextPeriodLastTwo = nextPeriod % 100;
                    // 格式化为两位数字符串
                    return nextPeriodLastTwo.toString().padStart(2, '0');
                } catch (e) {
                    return "00";
                }
            }
            
            // 生成预测历史记录
            generatePredictionHistory(data) {
                if (data.length < 10) {
                    return [];
                }
                
                const history = [];
                const limit = Math.min(50, data.length - 1);
                
                for (let i = 0; i < limit; i++) {
                    const trainingData = data.slice(i + 1);
                    const testPeriod = data[i];
                    
                    // 使用训练数据预测
                    const [finalResult, killResult, predictedBalls, ballConfidences] = this.sumBasedPrediction(trainingData);
                    
                    // 验证是否命中
                    const predictedTypes = [];
                    for (let j = 0; j < finalResult.length; j += 2) {
                        predictedTypes.push(finalResult.substring(j, j + 2));
                    }
                    
                    // 计算命中结果
                    let hitResult = "未中";
                    if (predictedTypes.includes(testPeriod.type)) {
                        hitResult = "中双组";
                    }
                    
                    // 检查杀组是否正确（杀组意思：下一期不会出现的组合）
                    // 如果开奖类型不等于杀组，则杀组命中
                    const killHit = testPeriod.type !== killResult;
                    
                    history.push({
                        period: testPeriod.period,
                        timeStr: testPeriod.timeStr,
                        numbers: testPeriod.numbers,
                        sum: testPeriod.sum,
                        type: testPeriod.type,
                        killPrediction: killResult,
                        prediction: finalResult,
                        hit: hitResult,
                        killHit: killHit
                    });
                }
                
                return history;
            }
            
            // 计算准确率统计
            calculateAccuracyStats(history) {
                if (!history || history.length === 0) {
                    return {
                        total: 0,
                        hit: 0,
                        killHit: 0,
                        accuracy: 0,
                        killAccuracy: 0
                    };
                }
                
                const total = history.length;
                const hit = history.filter(item => item.hit === "中双组").length;
                const killHit = history.filter(item => item.killHit).length;
                const accuracy = total > 0 ? (hit / total) * 100 : 0;
                const killAccuracy = total > 0 ? (killHit / total) * 100 : 0;
                
                return {
                    total: total,
                    hit: hit,
                    killHit: killHit,
                    accuracy: Math.round(accuracy),
                    killAccuracy: Math.round(killAccuracy)
                };
            }
        }

        // 创建预测器实例
        const predictor = new PC28Predictor();
        
        // DOM元素
        const fetchDataBtn = document.getElementById('fetchData');
        const loadingDiv = document.getElementById('loading');
        const resultsDiv = document.getElementById('results');
        const predictionTable = document.getElementById('predictionTable');
        const accuracySummary = document.getElementById('accuracySummary');
        const copyFinalResultBtn = document.getElementById('copyFinalResult');
        const finalOutput = document.getElementById('finalOutput');
        const periodCalculation = document.getElementById('periodCalculation');
        const periodResult = document.getElementById('periodResult');
        const killCalculation = document.getElementById('killCalculation');
        const killAlgorithmResult = document.getElementById('killAlgorithmResult');
        
        // 获取数据并预测
        fetchDataBtn.addEventListener('click', async () => {
            loadingDiv.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            try {
                // 获取彩票数据
                const rawData = await predictor.fetchLotteryData(100);
                if (!rawData || rawData.length === 0) {
                    alert('无法从网络获取数据');
                    loadingDiv.style.display = 'none';
                    return;
                }
                
                // 解析数据
                const periods = predictor.parseNetworkData(rawData);
                if (!periods || periods.length === 0) {
                    alert('网络数据解析失败');
                    loadingDiv.style.display = 'none';
                    return;
                }
                
                // 执行预测
                const [finalResult, killResult, predictedBalls, ballConfidences] = predictor.sumBasedPrediction(periods);
                
                // 计算置信度
                const [baseConfidence, killConfidence, ballConfidence] = predictor.calculateConfidence(
                    periods, finalResult, killResult, ballConfidences);
                
                // 生成特码
                const specialCodes = predictor.generatePreciseCodes(periods, finalResult, predictedBalls);
                
                // 生成预测历史记录
                const predictionHistory = predictor.generatePredictionHistory(periods);
                
                // 计算准确率统计
                const accuracyStats = predictor.calculateAccuracyStats(predictionHistory);
                
                // 计算期号算法预测
                const periodPrediction = predictor.calculatePeriodBasedPrediction(periods);
                
                // 计算新杀组算法预测
                const killPrediction = predictor.calculateKillByNewAlgorithm(periods);
                
                // 显示结果
                displayResults(
                    finalResult, killResult, specialCodes, 
                    baseConfidence, killConfidence, ballConfidence,
                    predictedBalls, ballConfidences, periods, predictionHistory, accuracyStats,
                    periodPrediction, killPrediction
                );
                
                loadingDiv.style.display = 'none';
                resultsDiv.style.display = 'block';
                
            } catch (error) {
                console.error('预测过程中出错:', error);
                alert('预测过程中出错: ' + error.message);
                loadingDiv.style.display = 'none';
            }
        });
        
        // 复制最终结果
        copyFinalResultBtn.addEventListener('click', function() {
            const textArea = document.createElement('textarea');
            textArea.value = finalOutput.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            // 显示复制成功提示
            const originalText = this.textContent;
            this.textContent = '已复制到剪贴板！';
            this.classList.add('copy-success');
            
            setTimeout(() => {
                this.textContent = originalText;
                this.classList.remove('copy-success');
            }, 2000);
        });
        
        // 显示预测结果
        function displayResults(
            finalResult, killResult, specialCodes, 
            baseConfidence, killConfidence, ballConfidence,
            predictedBalls, ballConfidences, data, predictionHistory, accuracyStats,
            periodPrediction, killPrediction
        ) {
            // 更新UI元素
            document.getElementById('finalResult').textContent = finalResult;
            document.getElementById('baseConfidence').textContent = `置信度: ${Math.round(baseConfidence)}%`;
            
            document.getElementById('killResult').textContent = killResult;
            document.getElementById('killConfidence').textContent = `置信度: ${Math.round(killConfidence)}%`;
            
            document.getElementById('specialCodes').textContent = specialCodes.map(code => code.toString().padStart(2, '0')).join(' ');
            
            document.getElementById('ballA').textContent = `${predictedBalls[0]} (${Math.round(ballConfidences[0])}%)`;
            document.getElementById('ballB').textContent = `${predictedBalls[1]} (${Math.round(ballConfidences[1])}%)`;
            document.getElementById('ballC').textContent = `${predictedBalls[2]} (${Math.round(ballConfidences[2])}%)`;
            
            const predictedSum = predictedBalls.reduce((a, b) => a + b, 0);
            document.getElementById('predictedSum').textContent = `${predictedSum}`;
            
            // 显示期号算法结果
            if (periodPrediction) {
                periodCalculation.textContent = periodPrediction.calculation;
                periodResult.textContent = `预测结果: ${periodPrediction.result} (${periodPrediction.type})`;
            } else {
                periodCalculation.textContent = "数据不足，无法计算";
                periodResult.textContent = "无法预测";
            }
            
            // 显示杀组算法结果
            if (killPrediction) {
                killCalculation.textContent = killPrediction.calculation;
                killAlgorithmResult.textContent = `杀组预测: ${killPrediction.value} (${killPrediction.type})`;
            } else {
                killCalculation.textContent = "数据不足，无法计算";
                killAlgorithmResult.textContent = "无法预测";
            }
            
            // 生成最终结果字符串 - 确保包含杀组预测和双组预测
            const nextPeriod = predictor.getNextPeriodNumber(data);
            const formattedCodes = specialCodes.map(code => code.toString().padStart(2, '0')).join(' ');
            
            // 最终结果格式：期号 杀组 双组预测 特码
            const finalOutputText = `${nextPeriod} 杀${killResult} ${finalResult} ${formattedCodes}`;
            
            finalOutput.textContent = finalOutputText;
            
            // 显示预测历史记录
            displayPredictionHistory(predictionHistory);
            
            // 显示准确率统计
            displayAccuracyStats(accuracyStats);
        }
        
        // 显示预测历史记录
        function displayPredictionHistory(history) {
            const tbody = predictionTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            if (!history || history.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6">暂无预测记录</td></tr>';
                return;
            }
            
            history.forEach(item => {
                const row = document.createElement('tr');
                
                // 根据命中状态设置CSS类
                let hitClass = '';
                let hitSymbol = '';
                
                if (item.killHit) {
                    hitClass = 'hit';
                    hitSymbol = '🀄️'; // 中杀组或全中
                } else {
                    hitClass = 'miss';
                    hitSymbol = '❌🀄️'; // 杀组没中则全不中
                }
                
                row.innerHTML = `
                    <td>${item.period}</td>
                    <td>${item.timeStr}</td>
                    <td>${item.numbers.join('+')}=${item.sum}</td>
                    <td>杀${item.killPrediction}</td>
                    <td>${item.prediction}</td>
                    <td class="${hitClass}">${hitSymbol}</td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // 显示准确率统计
        function displayAccuracyStats(stats) {
            if (stats.total === 0) {
                accuracySummary.innerHTML = '暂无统计信息';
                return;
            }
            
            // 计算命中率
            const hitRate = stats.killHit / stats.total * 100;
            
            accuracySummary.innerHTML = `
                近${stats.total}期预测准确率: ${stats.killHit}/${stats.total} = ${Math.round(hitRate)}%<br>
                <small>白云预测仅供参考 谨慎投资</small>
            `;
        }
    </script>
</body>
</html>